# Chinese translations for PACKAGE package
# Copyright (C) 2026 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2026.
#
msgid ""
msgstr ""
"Project-Id-Version: ceccomp docs\n"
"POT-Creation-Date: 2026-02-03 21:04+0800\n"
"PO-Revision-Date: 2026-02-03 21:08+0800\n"
"Last-Translator: Automatically generated\n"
"Language-Team: RocketDev\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.8\n"

#. type: Title =
#: ceccomp.adoc:1
#, no-wrap
msgid "ceccomp(1)"
msgstr "ceccomp(1)"

#. type: Plain text
#: ceccomp.adoc:3
msgid "dbgbgtf <dudududumaxver@outlook.com>; RocketDev <ma2014119@outlook.com>"
msgstr ""
"dbgbgtf <dudududumaxver@outlook.com>; RocketDev <ma2014119@outlook.com>"

#. type: Title ==
#: ceccomp.adoc:11
#, no-wrap
msgid "NAME"
msgstr "名称"

#. type: Plain text
#: ceccomp.adoc:14
msgid "ceccomp - A tool to analyze seccomp filters"
msgstr "ceccomp - 一个分析安全计算 (seccomp) 过滤器的工具"

#. type: Title ==
#: ceccomp.adoc:15
#, no-wrap
msgid "SYNOPSIS"
msgstr "大纲"

#. type: Plain text
#: ceccomp.adoc:20
#, no-wrap
msgid ""
"    usage: ceccomp <asm|disasm|emu|trace|probe|version|help> [FILE] [-q|--quiet]\n"
"                   [-f|--format FMT] [-a|--arch ARCH] [-p|--pid PID] [-s|--seize]\n"
"                   [-o|--output FILE] [-c|--color WHEN] ...\n"
msgstr ""
"    usage: ceccomp <asm|disasm|emu|trace|probe|version|help> [FILE] [-q|--quiet]\n"
"                   [-f|--format FMT] [-a|--arch ARCH] [-p|--pid PID] [-s|--seize]\n"
"                   [-o|--output FILE] [-c|--color WHEN] ...\n"

#. type: Title ==
#: ceccomp.adoc:21
#, no-wrap
msgid "CONCEPT"
msgstr "概念"

#. type: Plain text
#: ceccomp.adoc:26
msgid ""
"Kernel use BPF filters to limit syscall rules, applied via `seccomp` or "
"`prctl` syscall. For example, down below is a simple filter to block "
"`execve` syscall in hex format:"
msgstr ""
"内核使用BPF过滤器来限制系统调用规则，并使用 `seccomp` 和 `prctl` 两个系统调用"
"来安装过滤器。以下是一个以十六进制表示的限制 `execve` 系统调用的简单过滤器："

#. type: Plain text
#: ceccomp.adoc:31
#, no-wrap
msgid ""
"    1: 20 00 00 00 00 00 00 00     $A = $syscall_nr\n"
"    2: 15 00 00 01 3b 00 00 00     if ($A != execve) goto 4\n"
"    3: 06 00 00 00 00 00 00 00     return KILL\n"
"    4: 06 00 00 00 00 00 ff 7f     return ALLOW\n"
msgstr ""
"    1: 20 00 00 00 00 00 00 00     $A = $syscall_nr\n"
"    2: 15 00 00 01 3b 00 00 00     if ($A != execve) goto 4\n"
"    3: 06 00 00 00 00 00 00 00     return KILL\n"
"    4: 06 00 00 00 00 00 ff 7f     return ALLOW\n"

#. type: Plain text
#: ceccomp.adoc:35
msgid ""
"The part presented in hex is what kernel received, and `ceccomp` take it to "
"disassemble back to human readable text. For instance the *lineno* in the "
"left and *statement* in the right."
msgstr ""
"以上十六进制的部分就是内核收到的过滤器，而 `ceccomp` 负责把它拿来反汇编为人类"
"可读的文本。\n"
"例如左侧的 *行号* 和右侧的 *伪代码* 。"

#. type: Plain text
#: ceccomp.adoc:38
msgid ""
"Later I'll use _TEXT_ in short for BPF human readable text, and use _RAW_ in "
"short for BPF raw format, please keep that in mind."
msgstr ""
"之后我会使用 _TEXT_ 作为BPF过滤器人类可读文本（伪代码）的缩写，\n"
"使用 _RAW_ 作为BPF过滤器原始格式的缩写，请记住这个约定。"

#. type: Title ==
#: ceccomp.adoc:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "描述"

#. type: Plain text
#: ceccomp.adoc:44
msgid ""
"`ceccomp` have 5 main functions, basically it's a C version of `seccomp-"
"tools`, however, there are some breaking changes you need to know, which "
"will be highlighted in each subcommand section."
msgstr ""
"`ceccomp` 有5个主要的功能，它基本上是C版本的 `seccomp-tools` ，然而，\n"
"有一些不同的地方你需要知道，它们会在在每个子命令的章节中被注明。"

#. type: Title ===
#: ceccomp.adoc:45
#, no-wrap
msgid "asm - ASSEMBLE"
msgstr "asm - 汇编"

#. type: Plain text
#: ceccomp.adoc:48
#, no-wrap
msgid "    ceccomp asm [-c WHEN] [-a ARCH] [-f FMT] [TEXT]\n"
msgstr "    ceccomp asm [-c WHEN] [-a ARCH] [-f FMT] [TEXT]\n"

#. type: Plain text
#: ceccomp.adoc:51
msgid ""
"Assemble _TEXT_ to _RAW_. Use it to embed hand written filter rules into C "
"code or to see the original code of some _TEXT_."
msgstr ""
"将 _TEXT_ 汇编为 _RAW_ 。适用于将手写的过滤器规则嵌入到C代码中，\n"
"或希望观察一些 _TEXT_ 对应的原始字节码。"

#. type: Labeled list
#: ceccomp.adoc:52 ceccomp.adoc:101 ceccomp.adoc:140 ceccomp.adoc:190
#, no-wrap
msgid "WHEN"
msgstr "WHEN"

#. type: Plain text
#: ceccomp.adoc:56
msgid ""
"Determines when to display warnings and errors in color. If the value is "
"_auto_, ceccomp will display color when the output target is a \"tty\". Can "
"be _auto_, _never_ or _always_. The default value is _auto_."
msgstr ""
"决定了 `ceccomp` 何时输出有颜色的文本。当设置为 _auto_ 时， `ceccomp`\n"
"会在输出目标是一个“tty”时打印颜色。可以是 _auto_ 、 _never_ 或者 "
"_always_ 。\n"
"默认值是 _auto_ 。"

#. type: Labeled list
#: ceccomp.adoc:57 ceccomp.adoc:105 ceccomp.adoc:155
#, no-wrap
msgid "ARCH"
msgstr "ARCH"

#. type: Plain text
#: ceccomp.adoc:62
msgid ""
"Set to any architecture libseccomp supports. Will be used to determine the "
"actual syscall number behind the name (for example, on x86_64, you could "
"write `\"execve\"` instead of `59` like the basic example above). Your "
"system arch will be taken if not set via `uname`. The default value on your "
"system is {ARCH}."
msgstr ""
"可以设置为任何 libseccomp 支持的架构。它将被用于决定系统调用名称对应的系统调"
"用号。\n"
"例如，在 x86_64 上，就像上面的基本示例，你可以写 `\"execve\"` 而不是数字 "
"`59`\n"
"指代系统调用号。如果不设置这个参数，则通过 `uname` 提取当前系统的架构。\n"
"你的系统上的默认值是 {ARCH} 。"

#. type: Plain text
#: ceccomp.adoc:66
msgid ""
"Since _version 4.0_, endianness is considered. If target endianness *ARCH* "
"is different from machine endianness, the filters will be reversed (CODE and "
"K) before outputting."
msgstr ""
"从 _4.0 版本_ 开始考虑端序。如果目标架构 *ARCH* 的端序与机器端序不同，则会在"
"输出前反转过滤器（CODE 和 K）。"

#. type: Labeled list
#: ceccomp.adoc:67
#, no-wrap
msgid "FMT"
msgstr "FMT"

#. type: Plain text
#: ceccomp.adoc:71
msgid ""
"Determines how `ceccomp` produces binary-format bpf code. Can be _hexfmt_, "
"_hexline_ or _raw_. You could find sample output in <<EXAMPLES>> section.  "
"The default value is _hexline_."
msgstr ""
"决定了 `ceccomp` 如何输出二进制格式的BPF字节码。可以是 _hexfmt_ 、 "
"_hexline_\n"
"或者 _raw_ 。你可以在 <<ceccomp 示例>> 节中找到示例输出。默认值是 "
"_hexline_ 。"

#. type: Labeled list
#: ceccomp.adoc:72 ceccomp.adoc:158
#, no-wrap
msgid "TEXT"
msgstr "TEXT"

#. type: Plain text
#: ceccomp.adoc:75
msgid ""
"Take a optional filename to determine which file containing _TEXT_ will be "
"assembled. Will read from _stdin_ if not set."
msgstr ""
"一个可选的文件名，其中存放了需要被汇编的 _TEXT_ 。不设置则从 _标准输入_ 中读"
"取。"

#. type: Plain text
#: ceccomp.adoc:78
msgid ""
"The assembly syntax was changed greatly since _version 4.0_, please checkout "
"grammar reference below!"
msgstr "_4.0 版本_ 大幅修改了汇编的语法，请查阅下面的语法参考！"

#. type: Plain text
#: ceccomp.adoc:81
msgid ""
"Please check out <<TEXT GRAMMAR REFERENCE>> section to see how to write a "
"rule by hand. Some examples will be displayed in <<EXAMPLES>> section."
msgstr ""
"查看 <<TEXT 语法参考>> 一节可以找到如何手写规则。一些示例会在 <<ceccomp 示例"
">> 一节中展示。"

#. type: Table
#: ceccomp.adoc:92
#, no-wrap
msgid ""
"|Command|Difference\n"
"\n"
"|`seccomp-tools asm`\n"
"|Use its own grammar to assemble, a bit script like; can assemble invalid _TEXT_\n"
"which will be rejected by kernel\n"
"\n"
"|`ceccomp asm`\n"
"|You can just take `disasm` output to `asm`, no new grammar is needed to learn;\n"
"take `stdin` as input by default\n"
msgstr ""
"|命令|差别\n"
"\n"
"|`seccomp-tools asm`\n"
"|使用它自己的语法汇编，有点像脚本；可以汇编会被内核拒绝的错误 _TEXT_\n"
"\n"
"|`ceccomp asm`\n"
"|你可以直接拿着 `disasm` 的输出来汇编，不需要学习新语法；默认使用 _标准输入_ 作为输入\n"

#. type: Title ===
#: ceccomp.adoc:94
#, no-wrap
msgid "disasm - DISASSEMBLE"
msgstr "disasm - 反汇编"

#. type: Plain text
#: ceccomp.adoc:97
#, no-wrap
msgid "    ceccomp disasm [-c WHEN] [-a ARCH] [RAW]\n"
msgstr "    ceccomp disasm [-c WHEN] [-a ARCH] [RAW]\n"

#. type: Plain text
#: ceccomp.adoc:100
msgid ""
"Disassemble _RAW_ to _TEXT_. Use it to see what does a filter do if you "
"could not access filter via `trace` and have to manually extract the filter "
"out."
msgstr ""
"反汇编 _RAW_ 为 _TEXT_ 。适用于当你无法使用 `trace` 看到过滤器时，必须手动提"
"取过滤器，\n"
"然后检查其含义。"

#. type: Plain text
#: ceccomp.adoc:104
msgid ""
"Argument description can be found in <<asm - ASSEMBLE>> section. `disasm` "
"may print more text in color including syntax highlighting for _TEXT_."
msgstr ""
"参数描述可以在 <<asm - 汇编>> 一节中找到。 `disasm` 可能会打印更多有颜色的文"
"本，包括针对\n"
"_TEXT_ 的语法高亮。"

#. type: Plain text
#: ceccomp.adoc:110
msgid ""
"Set to any architecture libseccomp supports. Will be used to determine how "
"filtered syscall number in _RAW_ filter is translated to syscall name (for "
"example, on x86_64, the number `0x3b` is translated to `execve` if is "
"comparing syscall_nr, see the basic example above). The default value on "
"your system is {ARCH}."
msgstr ""
"可以设置为任何 libseccomp 支持的架构。它将被用于决定 _RAW_ 中的系统调用号如何"
"被翻译为系统调用名。\n"
"例如，在 x86_64 上，在比较系统调用号时，数字 `0x3b` 将被翻译为 `execve` ，可"
"以看上面的基本示例。\n"
"你的系统上的默认值是 {ARCH} 。"

#. type: Plain text
#: ceccomp.adoc:114
msgid ""
"Since _version 4.0_, endianness is considered. If target endianness *ARCH* "
"is different from machine endianness, the filters will be reversed (CODE and "
"K) before decoding."
msgstr ""
"从 _4.0 版本_ 开始考虑端序。如果目标架构 *ARCH* 的端序与机器端序不同，则会在"
"解码前反转过滤器（CODE 和 K）。"

#. type: Plain text
#: ceccomp.adoc:119
msgid ""
"ceccomp will try to resolve syscall number under an arch ONLY IF that at "
"that line, arch can be determined. On foreign arch (not equal to the arch "
"you set), the foreign arch will be prepended to syscall name. You may notice "
"that in some cases, seccomp-tools is able to resolve the name while ceccomp "
"is not, that may be intended as the arch is not determined."
msgstr ""
"当且仅当在某一行的架构可以被确定时，ceccomp 才会尝试用那个架构解析那个系统调"
"用号。\n"
"如果是外部架构（不等于你设置的架构），它会被附加到系统调用名前。你可能会注意"
"到在一些情况下，\n"
"seccomp-tools 能解析一些系统调用名，而 ceccomp 不能，这可能是因为此时架构不能"
"被确定。"

#. type: Table
#: ceccomp.adoc:129
#, no-wrap
msgid ""
"|Command|Difference\n"
"\n"
"|`seccomp-tools disasm`\n"
"|Disassembles in its format; never check if the filter is valid\n"
"\n"
"|`ceccomp disasm`\n"
"|Disassembles in ceccomp format, and takes `stdin` as input by default; check arch strictly\n"
"and always display foreign arch name\n"
msgstr ""
"|命令|差别\n"
"\n"
"|`seccomp-tools disasm`\n"
"|用它自己的语法反汇编；永远不会检查 _RAW_ 是否合法\n"
"\n"
"|`ceccomp disasm`\n"
"|用 ceccomp 语法反汇编，并且默认将 _标准输入_ 作为输入；严格检查架构，\n"
"并且永远打印外部架构名\n"

#. type: Title ===
#: ceccomp.adoc:131
#, no-wrap
msgid "emu - EMULATE"
msgstr "emu - 模拟"

#. type: Plain text
#: ceccomp.adoc:134
#, no-wrap
msgid "    ceccomp emu [-c WHEN] [-a ARCH] [-q] TEXT SYSCALL_NAME/SYSCALL_NR [ARGS[0] ARGS[1] ... ARGS[5] PC]\n"
msgstr "    ceccomp emu [-c WHEN] [-a ARCH] [-q] TEXT SYSCALL_NAME/SYSCALL_NR [ARGS[0] ARGS[1] ... ARGS[5] PC]\n"

#. type: Plain text
#: ceccomp.adoc:139
msgid ""
"Emulate what will happen if `syscall(SYSCALL_NR, ARGS[0], ARGS[1], ..., "
"ARGS[5])` from `PC` is called following rules described in _TEXT_. Use it to "
"see the result without actually running it in program or you don't want to "
"examine the filter rule manually. This subcommand can be used to "
"automatically examining a filter."
msgstr ""
"按照 _TEXT_ 中描述的规则，模拟从 `PC` 调用 `syscall(SYSCALL_NR, ARGS[0], "
"ARGS[1], ..., ARGS[5])`\n"
"的结果。适用于在不实际运行程序或不想手动检查规则时，查看触发系统调用的结"
"果。\n"
"这个子命令适合用来自动检测一个过滤器。"

#. type: Plain text
#: ceccomp.adoc:143
msgid ""
"Argument description can be found in <<asm - ASSEMBLE>> section. `emu` may "
"print more text in color including syntax highlighting for _TEXT_ and "
"skipped statements."
msgstr ""
"参数描述可以在 <<asm - 汇编>> 一节中找到。 `emu` 可能会打印更多有颜色的文本，"
"包括针对\n"
"_TEXT_ 的语法高亮以及跳过的伪代码。"

#. type: Labeled list
#: ceccomp.adoc:144
#, no-wrap
msgid "SYSCALL_NAME/SYSCALL_NR"
msgstr "SYSCALL_NAME/SYSCALL_NR"

#. type: Plain text
#: ceccomp.adoc:149
msgid ""
"If you set *SYSCALL_NAME* (like `execve`), it will be translated to "
"*SYSCALL_NR* under *ARCH* first. Or else set *SYSCALL_NR* directly (like "
"`59`). Then the nr will be tested against the bpf filter to see the result "
"of that syscall. This argument is NOT optional."
msgstr ""
"如果你设置了 *SYSCALL_NAME* （比如 `execve` ），那么它会基于 *ARCH* 先被翻译"
"为对应的\n"
"*SYSCALL_NR* 。或者你可以直接设置 *SYSCALL_NR* （例如 `59` ）。然后会测试这个"
"系统调用号经过\n"
"BPF 过滤器处理后的输出并打印出来。这个参数是必填的。"

#. type: Labeled list
#: ceccomp.adoc:150
#, no-wrap
msgid "ARGS[0-5] and PC"
msgstr "ARGS[0-5] 和 PC"

#. type: Plain text
#: ceccomp.adoc:154
msgid ""
"Register values when calling syscall. For example, on x86_64, these are "
"equivalent to `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9` and `rip`. Their "
"default value is 0."
msgstr ""
"当调用系统调用时对应寄存器的值。例如，在 x86_64 上，它们分别对应了\n"
"`rdi` 、 `rsi` 、 `rdx` 、 `r10` 、 `r8` 、 `r9` 和 `rip` 。它们的默认值都是"
"0。"

#. type: Plain text
#: ceccomp.adoc:157
msgid "Argument description can be found in <<asm - ASSEMBLE>> section."
msgstr "参数描述可以在 <<asm - 汇编>> 一节中找到。"

#. type: Plain text
#: ceccomp.adoc:162
msgid ""
"Take a filename to determine which file containing _TEXT_ rule will be "
"tested.  Note that filename CAN NOT be ignored as ceccomp can not determine "
"if a positional argument is syscall or filename."
msgstr ""
"一个文件名，其中存放了需要被测试的 _TEXT_ 规则。注意文件名 不能 被忽略，因为 "
"ceccomp 无法判断一个位置参数是系统调用号还是文件名。"

#. type: Labeled list
#: ceccomp.adoc:163 ceccomp.adoc:215
#, no-wrap
msgid "-q, --quiet"
msgstr "-q, --quiet"

#. type: Plain text
#: ceccomp.adoc:166
msgid ""
"Only print the eval result of the filter. For example, if last statement "
"emulated is `return KILL`, then `KILL` is printed."
msgstr ""
"只打印过滤器的模拟结果。例如，最后一行模拟的伪代码是 `return KILL`，那么将会"
"打印 `KILL`。"

#. type: Table
#: ceccomp.adoc:176
#, no-wrap
msgid ""
"|Command|Difference\n"
"\n"
"|`seccomp-tools emu`\n"
"|Take a _RAW_ as input\n"
"\n"
"|`ceccomp emu`\n"
"|Take a _TEXT_ as input and take `stdin` as input by default; set *PC* is\n"
"possible\n"
msgstr ""
"|命令|差别\n"
"\n"
"|`seccomp-tools emu`\n"
"|用 _RAW_ 作为输入\n"
"\n"
"|`ceccomp emu`\n"
"|用 _TEXT_ 作为输入，并默认将 _标准输入_ 作为输入；可以设置 *PC*\n"

#. type: Title ===
#: ceccomp.adoc:178
#, no-wrap
msgid "trace - TRACE FILTER IN RUNTIME"
msgstr "trace - 运行时捕获过滤器"

#. type: Plain text
#: ceccomp.adoc:182
#, no-wrap
msgid ""
"    ceccomp trace [-c WHEN] [-q] [-o FILE] PROGRAM [program-args]\n"
"                  [-c WHEN] [-q] -p PID [-s]\n"
msgstr ""
"    ceccomp trace [-c WHEN] [-o FILE] PROGRAM [program-args]\n"
"                  [-c WHEN] -p PID [-s]\n"

#. type: Plain text
#: ceccomp.adoc:189
msgid ""
"The first line captures filters *PROGRAM* loads in runtime by tracing it; "
"the second line extract seccomp filters from *PID*, or trace *PID* to "
"capture subsequent seccomp filters; once fetched filters, print them in "
"_TEXT_.  You can only choose one of the two formats above. Use this if "
"running the program is the simplest way to fetch bpf filters or a program "
"with seccomp filters installed is waiting for input."
msgstr ""
"使用第一行的命令可以利用调试在 *PROGRAM* 运行中加载过滤器时动态捕获过滤器；\n"
"第二行的命令可以从 *PID* 对应的进程中提取出 seccomp 过滤器，或通过调试 *PID* "
"捕获后续的 seccomp 过滤器；一旦捕获到了过滤器，\n"
"将会以 _TEXT_ 的格式将它打印出来。你可以从两个格式中选择一个使用。\n"
"适用于运行一个程序是捕获BPF过滤器最简单的方式或者一个安装了 seccomp\n"
"过滤器的程序正在等待输入。"

#. type: Plain text
#: ceccomp.adoc:193
msgid ""
"Argument description can be found in <<asm - ASSEMBLE>> section. `trace` may "
"print more text in color including syntax highlighting for _TEXT_."
msgstr ""
"参数描述可以在 <<asm - 汇编>> 一节中找到。 `trace` 可能会打印更多有颜色的文"
"本，包括针对\n"
"_TEXT_ 的语法高亮。"

#. type: Labeled list
#: ceccomp.adoc:194
#, no-wrap
msgid "FILE"
msgstr "FILE"

#. type: Plain text
#: ceccomp.adoc:199
msgid ""
"May be useful when *PROGRAM* produces quite a lot output in _stderr_.  "
"`ceccomp` allow user to close _stdin_ and _stdout_ to limit *PROGRAM* input "
"and output, so `ceccomp` use _stderr_ to print messages when running "
"*PROGRAM*, set *FILE* if you want to see _TEXT_ in some other file."
msgstr ""
"当 *PROGRAM* 会产生很多输出到 _标准错误_ 时可能很有用。 `ceccomp` 允许用户关"
"闭\n"
"_标准输入_ 和 _标准输出_ 来限制 *PROGRAM* 的输入和输出，所以 当运行\n"
"*PROGRAM* 时 `ceccomp` 使用 _标准错误_ 来打印消息。如果你想在别的文件中看见\n"
"_TEXT_ 的话请设置 *FILE* 。"

#. type: Labeled list
#: ceccomp.adoc:200
#, no-wrap
msgid "PROGRAM"
msgstr "PROGRAM"

#. type: Plain text
#: ceccomp.adoc:203
msgid ""
"Set to the program you want to run, and *program-args* are its arguments "
"just like running shell command `exec PROGRAM program-args`."
msgstr ""
"设置为你想运行的程序，并且 *program-args* 将作为它的参数，\n"
"就像运行 shell 命令 `exec PROGRAM program-args` 。"

#. type: Labeled list
#: ceccomp.adoc:204
#, no-wrap
msgid "PID"
msgstr "PID"

#. type: Plain text
#: ceccomp.adoc:209
msgid ""
"Set to the pid you want to inspect. *PID* is conflict with *PROGRAM*; you "
"could either run a program dynamically or examine a pid in one command.  "
"Without `-s` flag, trace pid will try to extract seccomp filter in *PID* via "
"`ptrace(PTRACE_SECCOMP_GET_FILTER)`, which may not be available in some "
"systems."
msgstr ""
"设置为你想检查的 pid。 *PID* 和 *PROGRAM* 相冲突；你只能在一条命令中动态运行"
"一个程序，\n"
"或者检查一个 pid。没有 `-s` 标志，trace pid 会尝试使用 "
"`ptrace(PTRACE_SECCOMP_GET_FILTER)` 从 *PID* 中提取 seccomp 过滤器，这个操作"
"在一些系统上可能不可用。"

#. type: Labeled list
#: ceccomp.adoc:210
#, no-wrap
msgid "-s, --seize"
msgstr "-s, --seize"

#. type: Plain text
#: ceccomp.adoc:214
msgid ""
"*ONLY AVAILABLE FOR TRACE PID MODE.* Set this flag will override trace pid "
"behavior to attach to *PID* and keep tracing for seccomp filter loading like "
"trace prog mode. _This flag was introduced in version 4.0._"
msgstr ""
"*只适用于 TRACE PID 模式。* 设置这个标志将会覆盖 trace pid 的行为为像 trace "
"prog 模式一样把调试器挂到 *PID* 上并持续跟踪 seccomp 过滤器的加载。_这个标志"
"引入于 4.0 版本。_"

#. type: Plain text
#: ceccomp.adoc:218
msgid ""
"Set to suppress the extra *[INFO]* prints when detect process forking, "
"exiting or seccomp filter loading. _This flag was introduced in version 4.0._"
msgstr ""
"设置这个标志将会在检测到进程分叉、退出或加载 seccomp 过滤器时抑制多余的 "
"*[INFO]* 输出。 _这个标志引入于 4.0 版本。_"

#. type: Plain text
#: ceccomp.adoc:222
msgid ""
"To extract filters from *PID*, `CAP_SYS_ADMIN` is needed (without `-s` "
"flag)  and `CAP_SYS_PTRACE` may also be needed, the easiest way to acquire "
"them is calling `ceccomp` with `sudo`."
msgstr ""
"要想从 *PID* 中提取过滤器，你需要 `CAP_SYS_ADMIN` （没有 `-s` 标志），同时还"
"可能需要\n"
"`CAP_SYS_PTRACE` ，最简单的获取它们的方法是用 `sudo` 运行 `ceccomp` 。"

#. type: Plain text
#: ceccomp.adoc:226
msgid ""
"Since _version 3.1_, multiple process tracing is introduced, and when tracee "
"forking/resolving/exiting, an extra INFO message is printed. You can discard "
"it by running command like `ceccomp trace -q PROG 2>/dev/null`."
msgstr ""
"从 _3.1 版本_ 开始引入了多进程支持，并且当被调试进程 fork/resolve/exit\n"
"时，将会打印一条额外的 INFO 信息。你可以使用像 `ceccomp trace -q PROG 2>/dev/"
"null`\n"
"这样的命令丢弃它。"

#. type: Table
#: ceccomp.adoc:239
#, no-wrap
msgid ""
"|Command|Difference\n"
"\n"
"|`seccomp-tools dump`\n"
"|Setting output format is possible; each filter can be output to a different\n"
"file; killing *PROGRAM* once *LIMIT* times of filters loaded; wrapping *PROGRAM*\n"
"in `sh -c`\n"
"\n"
"|`ceccomp trace`\n"
"|All filters are output to a single file; never kill *PROGRAM*; *PROGRAM* is\n"
"launched directly, so `./` is not needed; explicitly print when forking;\n"
"able to attach to pid for dynamic seccomp filter capturing\n"
msgstr ""
"|命令|差别\n"
"\n"
"|`seccomp-tools dump`\n"
"|可以设置输出格式；每一个过滤器可以输出到不同的文件；当 *PROGRAM*\n"
"加载了 *LIMIT* 个过滤器后就杀死程序；将 *PROGRAM* 包装在 `sh -c` 中运行\n"
"\n"
"|`ceccomp trace`\n"
"|所有过滤器被输出到同一个文件；永远不会杀死 *PROGRAM* ； *PROGRAM* 是直接被执行的，\n"
"所以不需要 `./` ；当 fork 时，显式打印事件；能够附加调试器到 pid 上动态捕捉 seccomp 过滤器\n"

#. type: Title ===
#: ceccomp.adoc:241
#, no-wrap
msgid "probe - TEST COMMON SYSCALLS INSTANTLY"
msgstr "probe - 快速测试常见的系统调用"

#. type: Plain text
#: ceccomp.adoc:244
#, no-wrap
msgid "    ceccomp probe [-c WHEN] [-o FILE] [-q] PROGRAM [program-args]\n"
msgstr "    ceccomp probe [-c WHEN] [-o FILE] [-q] PROGRAM [program-args]\n"

#. type: Plain text
#: ceccomp.adoc:248
msgid ""
"Run *PROGRAM* with *program-args* to captures *FIRST* seccomp filter, and "
"then kill all children. Use it when a quick check against a program is "
"needed, and detect potential seccomp rule issues."
msgstr ""
"以 *program-args* 为参数运行 *PROGRAM* 来捕获 *第一个* seccomp 过滤器，\n"
"然后杀死所有子进程。适用于快速测试一个程序的规则并检测潜在的 seccomp\n"
"规则问题。"

#. type: Plain text
#: ceccomp.adoc:250
msgid ""
"All argument descriptions can be found in <<trace - TRACE FILTER IN "
"RUNTIME>> section."
msgstr "所有参数描述都可以在 <<trace - 运行时捕获过滤器>> 一节中找到。"

#. type: Plain text
#: ceccomp.adoc:254
msgid ""
"The output for this subcommand is the emulating result of common syscalls "
"like `execve`, `open` and so on. If the filter itself is not capable of "
"blocking syscalls, you could know that with a glance."
msgstr ""
"这个子命令的输出是一系列常见的系统调用的模拟结果，例如 `execve` 、 `open` "
"等。\n"
"如果过滤器本身并不能阻拦系统调用，那你一眼就能看出来。"

#. type: Plain text
#: ceccomp.adoc:257
msgid ""
"Typical output for this subcommand is described below, more detailed example "
"could be found in <<EXAMPLES>> section."
msgstr ""
"这个子命令的典型输出如下所示，更多完整的实例可以在 <<ceccomp 示例>> 一节中找"
"到。"

#. type: Plain text
#: ceccomp.adoc:269
#, no-wrap
msgid ""
"    open      -> ALLOW\n"
"    read      -> ALLOW\n"
"    write     -> ALLOW\n"
"    execve    -> KILL\n"
"    execveat  -> KILL\n"
"    mmap      -> ALLOW\n"
"    mprotect  -> ALLOW\n"
"    openat    -> ALLOW\n"
"    sendfile  -> ALLOW\n"
"    ptrace    -> ERRNO(1)\n"
"    fork      -> ALLOW\n"
msgstr ""
"    open      -> ALLOW\n"
"    read      -> ALLOW\n"
"    write     -> ALLOW\n"
"    execve    -> KILL\n"
"    execveat  -> KILL\n"
"    mmap      -> ALLOW\n"
"    mprotect  -> ALLOW\n"
"    openat    -> ALLOW\n"
"    sendfile  -> ALLOW\n"
"    ptrace    -> ERRNO(1)\n"
"    fork      -> ALLOW\n"

#. type: Plain text
#: ceccomp.adoc:271
msgid "`seccomp-tools` don't have this subcommand."
msgstr "`seccomp-tools` 没有等价的子命令。"

#. type: Title ==
#: ceccomp.adoc:272
#, no-wrap
msgid "TEXT GRAMMAR REFERENCE"
msgstr "TEXT 语法参考"

#. type: Plain text
#: ceccomp.adoc:279
msgid ""
"The grammar changed greatly since _version 4.0_ as we refactored lexer for "
"better human readability. The wrapper now prefixed by `#` as it's a comment "
"now. And _line_ is replaced by _label_, so now lexer depends on label "
"declaration to decide where to jump, instead of lineno in _TEXT_ file."
msgstr ""
"_4.0 版本_ 提高了词法分析器代码的可读性，伴随着大幅修改的语法。前缀为 `#` 的"
"行现在是注释了。同时 _行号_ 被替换为 _标签_，现在词法分析器根据标签定义来决定"
"跳转到哪里，而不是根据 _TEXT_ 文件中的行号。"

#. type: Plain text
#: ceccomp.adoc:284
msgid ""
"A valid _TEXT_ format is described in EBNF-like declaration here: https://"
"github.com/dbgbgtf1/Ceccomp/issues/17#issuecomment-3610531705.  If you have "
"no interest to know what EBNF is, please keep reading for examples."
msgstr ""
"这里有正确的 _TEXT_ 格式，以类 EBNF 语法描述：https://github.com/dbgbgtf1/"
"Ceccomp/issues/17#issuecomment-3610531705。\n"
"没兴趣了解 EBNF？请继续阅读以下的例子。"

#. type: Plain text
#: ceccomp.adoc:286
msgid "BPF ops which are not described below are banned by kernel."
msgstr "其余未描述到的BPF操作都被内核禁止了。"

#. type: Title ===
#: ceccomp.adoc:287
#, no-wrap
msgid "Comment and Label"
msgstr "注释与标签"

#. type: Plain text
#: ceccomp.adoc:291
msgid ""
"`ceccomp disasm` displays a lot of things, but some of them are optional for "
"asm."
msgstr "`ceccomp disasm` 展示了很多东西，但对于 asm 来说有些是可选的。"

#. type: Plain text
#: ceccomp.adoc:296
#, no-wrap
msgid ""
"    #Label  CODE  JT   JF      K\n"
"    #---------------------------------\n"
"     L0001: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n"
"    #---------------------------------\n"
msgstr ""
"    #Label  CODE  JT   JF      K\n"
"    #---------------------------------\n"
"     L0001: 0x06 0x00 0x00 0x7fff0000 return ALLOW\n"
"    #---------------------------------\n"
"\n"

#. type: Plain text
#: ceccomp.adoc:298
msgid "Any text after `#` will be discarded by asm like some script languages."
msgstr "任何在 `#` 之后的文本将被 asm 丢弃，就像一些脚本语言一样。"

#. type: Plain text
#: ceccomp.adoc:300
msgid "Empty lines are accepted."
msgstr "允许空行。"

#. type: Plain text
#: ceccomp.adoc:308
msgid ""
"Label declaration is an identifier at the beginning of line and suffixed by "
"`:` like `L0001`. An identifier is a string starts with alpha and contains "
"with only alphanumeric characters and underscore `_`. Label is only "
"necessary if it's the destination of `goto`, these redundant labels added by "
"disasm are for readability. E.g. in `if ($A == 0) goto somewhere`, "
"`somewhere` is a label and must be declared after the statement. Label "
"declaration can take a line separately, or be put in front of statement."
msgstr ""
"标签声明是一个从行首开始并以 `:` 结尾的标识符，例如 `L0001`。标识符是一个以字"
"母为首，中间只包含字母、数字和下划线 `_` 的字符串。标签只在它是 `goto` 的目标"
"时才是必要的，由 disasm 添加的多余的标签知识为了可读性。例如在 `if ($A == 0) "
"goto somewhere` 中，`somewhere` 是一个标签并且必须在这行伪代码后声明。标签声"
"明可以单独占据一行，也可以放置在伪代码的前面。"

#. type: Plain text
#: ceccomp.adoc:311
msgid ""
"The `CODE`, `JT`, `JF` and `K` value generated by disasm will be discarded "
"by asm, asm only parse the effective statement after `K`."
msgstr ""
"由 disasm 生成的 `CODE`、`JT`、`JF` 和 `K` 值会被 asm 丢弃，asm 之解析 `K` 之"
"后的有效伪代码。"

#. type: Plain text
#: ceccomp.adoc:316
msgid ""
"There are some slight difference between `ceccomp disasm` and `seccomp-tools "
"disasm`, down below is a general example. And some statements are different, "
"so don't pipe seccomp-tools output to ceccomp blindly."
msgstr ""
"`ceccomp disasm` 和 `seccomp-tools disasm` 的输出之间有很多细微的差别，\n"
"以下是一个典型的输出示例。同时有些伪代码是不同的，所以不要盲目将 seccomp-"
"tools\n"
"的输出管道给 ceccomp。"

#. type: Plain text
#: ceccomp.adoc:320
#, no-wrap
msgid ""
"    line  CODE  JT   JF      K\n"
"    =================================\n"
"    0000: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n"
msgstr ""
"    line  CODE  JT   JF      K\n"
"    =================================\n"
"    0000: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n"

#. type: Title ===
#: ceccomp.adoc:321
#, no-wrap
msgid "Assignment"
msgstr "赋值"

#. type: Plain text
#: ceccomp.adoc:325
msgid ""
"`A` can be set to seccomp attributes directly. But `X` can not be assigned "
"with seccomp attributes directly due to kernel limit."
msgstr ""
"`A` 可以直接赋值为 seccomp 属性。由于内核限制， `X` 不能直接赋值为 seccomp 属"
"性。"

#. type: Plain text
#: ceccomp.adoc:328
#, no-wrap
msgid ""
"    $A = $arch\n"
"    $A = $syscall_nr\n"
msgstr ""
"    $A = $arch\n"
"    $A = $syscall_nr\n"

#. type: Plain text
#: ceccomp.adoc:330
msgid ""
"To assign `A` with those 64-bit long fields, `low_` or `high_` prefix is "
"needed."
msgstr "要给 `A` 赋值为这些64位长的字段，必须使用 `low_` 或者 `high_` 的前缀。"

#. type: Plain text
#: ceccomp.adoc:338
#, no-wrap
msgid ""
"    $A = $low_pc\n"
"    $A = $high_pc\n"
"    $A = $low_args[0]\n"
"    $A = $high_args[0]\n"
"    ...\n"
"    $A = $low_args[5]\n"
"    $A = $high_args[5]\n"
msgstr ""
"    $A = $low_pc\n"
"    $A = $high_pc\n"
"    $A = $low_args[0]\n"
"    $A = $high_args[0]\n"
"    ...\n"
"    $A = $low_args[5]\n"
"    $A = $high_args[5]\n"

#. type: Plain text
#: ceccomp.adoc:341
msgid ""
"A special attribute is `sizeof(struct seccomp_data)`, that can be assigned "
"to `A` or `X` directly."
msgstr ""
"一个特殊的属性是 `sizeof(struct seccomp_data)` ，它可以直接赋值给 `A` 或 "
"`X` 。"

#. type: Plain text
#: ceccomp.adoc:344
#, no-wrap
msgid ""
"    $A = $scmp_data_len\n"
"    $X = $scmp_data_len\n"
msgstr ""
"    $A = $scmp_data_len\n"
"    $X = $scmp_data_len\n"

#. type: Plain text
#: ceccomp.adoc:348
msgid ""
"Temporary memory is 32-bit, to access them, you could use hex or dec as "
"index.  Both `A` and `X` is assignable. Assigning immediate values to `A` or "
"`X` accepts hexadecimal numbers prefixed by `0x` and common decimal numbers."
msgstr ""
"临时内存是32位的，要想访问它们，你可以使用十六进制或者十进制的索引。\n"
"`A` 和 `X` 都是可赋值的。给 `A` 或 `X` 赋值为立即数接受以 `0x` 开头的十六进制"
"数字和一般的十进制数字。"

#. type: Plain text
#: ceccomp.adoc:354
#, no-wrap
msgid ""
"    $X = $mem[0]\n"
"    $A = $mem[0xf]\n"
"    $A = $mem[15] # both hex and dec index are OK\n"
"    $A = 0\n"
"    $X = 0x3b\n"
msgstr ""
"    $X = $mem[0]\n"
"    $A = $mem[0xf]\n"
"    $A = $mem[15] # both hex and dec index are OK\n"
"    $A = 0\n"
"    $X = 0x3b\n"

#. type: Plain text
#: ceccomp.adoc:357
msgid ""
"You could also assign `X` to `A` or in the reverse order. Assign `X` or `A` "
"to temporary memory is definitely okay."
msgstr ""
"你还可以将 `X` 赋值给 `A` 或者反过来。将 `X` 或 `A` 赋值给临时内存当然可以。"

#. type: Plain text
#: ceccomp.adoc:362
#, no-wrap
msgid ""
"    $A = $X\n"
"    $X = $A\n"
"    $mem[3] = $X\n"
"    $mem[0x4] = $A\n"
msgstr ""
"    $A = $X\n"
"    $X = $A\n"
"    $mem[3] = $X\n"
"    $mem[0x4] = $A\n"

#. type: Title ===
#: ceccomp.adoc:363
#, no-wrap
msgid "Arithmetic Operations"
msgstr "数学运算"

#. type: Plain text
#: ceccomp.adoc:366
msgid "Various operations can be applied to `A`."
msgstr "你可以以多种方式操作 `A` 。"

#. type: Plain text
#: ceccomp.adoc:373
#, no-wrap
msgid ""
"    $A += 30\n"
"    $A -= 4\n"
"    $A *= 9\n"
"    $A /= 1\n"
"    $A &= 7\n"
"    $A >>= 6\n"
msgstr ""
"    $A += 30\n"
"    $A -= 4\n"
"    $A *= 9\n"
"    $A /= 1\n"
"    $A &= 7\n"
"    $A >>= 6\n"

#. type: Plain text
#: ceccomp.adoc:375
msgid "The right value can be `X`."
msgstr "右值也可以是 `X` 。"

#. type: Plain text
#: ceccomp.adoc:380
#, no-wrap
msgid ""
"    $A &= $X\n"
"    $A |= $X\n"
"    $A ^= $X\n"
"    $A <<= $X\n"
msgstr ""
"    $A &= $X\n"
"    $A |= $X\n"
"    $A ^= $X\n"
"    $A <<= $X\n"

#. type: Plain text
#: ceccomp.adoc:382
msgid "And there is a way to negativate `A`."
msgstr "想要对 `A` 取反可以这么做。"

#. type: Plain text
#: ceccomp.adoc:384
#, no-wrap
msgid "    $A = -$A\n"
msgstr "    $A = -$A\n"

#. type: Title ===
#: ceccomp.adoc:385
#, no-wrap
msgid "Jump Downwards If ..."
msgstr "当...时向下跳转"

#. type: Plain text
#: ceccomp.adoc:388
msgid "Unconditional jump:"
msgstr "无条件跳转："

#. type: Plain text
#: ceccomp.adoc:390
#, no-wrap
msgid "    goto L3\n"
msgstr "    goto L3\n"

#. type: Plain text
#: ceccomp.adoc:392
msgid "Jump if:"
msgstr "当...跳转："

#. type: Plain text
#: ceccomp.adoc:398
#, no-wrap
msgid ""
"    if ($A == execve) goto L3\n"
"    if ($A != 1234) goto L4\n"
"    if ($A & $X) goto L5\n"
"    if !($A & 7) goto L6\n"
"    if ($A <= $X) goto L7\n"
msgstr ""
"    if ($A == execve) goto L3\n"
"    if ($A != 1234) goto L4\n"
"    if ($A & $X) goto L5\n"
"    if !($A & 7) goto L6\n"
"    if ($A <= $X) goto L7\n"

#. type: Plain text
#: ceccomp.adoc:400
msgid "If true jump to ... if false jump to...:"
msgstr "当条件为真时跳转到...，条件为假时跳转到...："

#. type: Plain text
#: ceccomp.adoc:403
#, no-wrap
msgid ""
"    if ($A > $X) goto L3, else goto L4\n"
"    if ($A >= 4567) goto L5, else goto L6\n"
msgstr ""
"    if ($A > $X) goto L3, else goto L4\n"
"    if ($A >= 4567) goto L5, else goto L6\n"

#. type: Plain text
#: ceccomp.adoc:410
msgid ""
"ONLY in conditions, you CAN replace number with syscall name or arch name.  "
"In example above, `0x3b` is replaced by `execve`. All the syscall name will "
"be resolved to syscall number under your selected arch. If you want to "
"resolve a syscall name in foreign arch (not equal to your selected arch), "
"please prepend a arch and dot. For example, your arch is x86_64, and you are "
"writing _aarch64_ rules, then please write like:"
msgstr ""
"*只有* 在做条件判断时，你才能将数字替换为系统调用号或架构名。在以上的例子"
"中， `0x3b`\n"
"被 `execve` 替换。所有系统调用名将会以你设置的架构解析为系统调用号。\n"
"如果你希望解析外部架构（不等于你设置的架构）的系统调用名，\n"
"请在前面附加架构名和一个点。例如，你设置的架构是 x86_64，并且你正在写\n"
"_aarch64_ 架构的规则，请这样写："

#. type: Plain text
#: ceccomp.adoc:412
#, no-wrap
msgid "    if ($A == aarch64.read) goto 5\n"
msgstr "    if ($A == aarch64.read) goto 5\n"

#. type: Plain text
#: ceccomp.adoc:415
msgid ""
"Note that if you manually set arch to _aarch64_ with `-a aarch64`, you can "
"omit `aarch64.` in statement."
msgstr ""
"注意当你手动使用 `-a aarch64` 将架构设置为 _aarch64_ 时，\n"
"你可以在伪代码中忽略 `aarch64.` 。"

#. type: Title ===
#: ceccomp.adoc:416
#, no-wrap
msgid "Return Code"
msgstr "返回码"

#. type: Plain text
#: ceccomp.adoc:419
msgid "Return value of register `A`:"
msgstr "返回寄存器 `A` 的值："

#. type: Plain text
#: ceccomp.adoc:421
#, no-wrap
msgid "    return $A\n"
msgstr "    return $A\n"

#. type: Plain text
#: ceccomp.adoc:425
msgid ""
"Or return a immediate value, with extra field in `()`. Actions including "
"`TRACE`, `TRAP` and `ERRNO` accept an extra field, without `()`, they are "
"treated as `action(0)`."
msgstr ""
"或者返回一个立即数，多余的字段放在 `()` 里。 `TRACE` 、 `TRAP` 和 `ERRNO`\n"
"接受一个额外的字段，如果没有 `()` ，它们将被视为 `行为(0)` 。"

#. type: Plain text
#: ceccomp.adoc:435
#, no-wrap
msgid ""
"    return 0x13371337\n"
"    return KILL\n"
"    return KILL_PROCESS\n"
"    return TRAP(123)\n"
"    return ERRNO(0)\n"
"    return TRACE\n"
"    return TRACE(3)\n"
"    return LOG\n"
"    return NOTIFY\n"
msgstr ""
"    return 0x13371337\n"
"    return KILL\n"
"    return KILL_PROCESS\n"
"    return TRAP(123)\n"
"    return ERRNO(0)\n"
"    return TRACE\n"
"    return TRACE(3)\n"
"    return LOG\n"
"    return NOTIFY\n"

#. type: Title ===
#: ceccomp.adoc:436
#, no-wrap
msgid "Short Example"
msgstr "简短的例子"

#. type: Plain text
#: ceccomp.adoc:440
msgid ""
"The following _TEXT_ is valid for asm, which blocks `execve` and `execveat` "
"for amd64 syscalls:"
msgstr ""
"下面的 _TEXT_ 对与 asm 来说是正确的，这段 _TEXT_ 阻止了 amd64 的 `execve` 和 "
"`execveat` 系统调用："

#. type: Plain text
#: ceccomp.adoc:446
#, no-wrap
msgid ""
"    $A = $syscall_nr\n"
"    if ($A == execve) goto forbid\n"
"    if ($A == execveat) goto forbid\n"
"    return ALLOW\n"
"    forbid: return KILL\n"
msgstr ""
"    $A = $syscall_nr\n"
"    if ($A == execve) goto forbid\n"
"    if ($A == execveat) goto forbid\n"
"    return ALLOW\n"
"    forbid: return KILL\n"

#. type: Title ==
#: ceccomp.adoc:447
#, no-wrap
msgid "RESTRICTIONS"
msgstr "限制"

#. type: Plain text
#: ceccomp.adoc:450
msgid "Ceccomp asm put some restrictions on _TEXT_ for better performance."
msgstr "为了更好的性能，Ceccomp asm 对 _TEXT_ 有一些限制。"

#. type: Plain text
#: ceccomp.adoc:452
msgid "`'\\0'` must not be found in _TEXT_ since it's a text file."
msgstr "由于 _TEXT_ 是个文本文件，`'\\0'` 不能出现在 _TEXT_ 中。"

#. type: Plain text
#: ceccomp.adoc:453
msgid "A line must be shorter than 384 *bytes*."
msgstr "一行必须短于 384 *字节*。"

#. type: Plain text
#: ceccomp.adoc:454
msgid "A _TEXT_ file must have less than 4096 lines."
msgstr "一个 _TEXT_ 文件必须短于 4096 行。"

#. type: Plain text
#: ceccomp.adoc:455
msgid "A _TEXT_ file must be smaller than 1 MiB."
msgstr "一个 _TEXT_ 文家必须小于 1 MiB。"

#. type: Plain text
#: ceccomp.adoc:458
msgid ""
"And for both asm and disasm, effective statements (that can be encoded or "
"decoded into BPF) must be less or equal than 1024, this is enforced by "
"kernel."
msgstr ""
"并且对于 asm 和 disasm 来说，有效的伪代码（能被编码或解码为 BPF 的）必须少于"
"等于 1024 条，这是内核规定的。"

#. type: Plain text
#: ceccomp.adoc:461
msgid ""
"A fun fact about ceccomp asm: any basic ANSI color in _TEXT_ file, e.g., "
"`\\x1b[31m`, will be discarded when processing."
msgstr ""
"一个关于 ceccomp asm 有趣的知识：任何在 _TEXT_ 文件中基本的 ANSI 颜色，例如 "
"`\\x1b[31m`，会在处理时被丢弃。"

#. type: Title ==
#: ceccomp.adoc:462
#, no-wrap
msgid "EXAMPLES"
msgstr "ceccomp 示例"

#. type: Plain text
#: ceccomp.adoc:467
msgid ""
"Manpage can not display images, so please check out html version of this "
"page to see examples."
msgstr "手册不能显示图片，因此如果想看示例请参阅html版本。"

#. type: Title ===
#: ceccomp.adoc:470
#, no-wrap
msgid "asm example"
msgstr "asm 示例"

#. type: Target for macro image
#: ceccomp.adoc:471
#, no-wrap
msgid "asm.png"
msgstr "asm.png"

#. type: Title ===
#: ceccomp.adoc:472
#, no-wrap
msgid "disasm example"
msgstr "disasm 示例"

#. type: Target for macro image
#: ceccomp.adoc:473
#, no-wrap
msgid "disasm.png"
msgstr "disasm.png"

#. type: Title ===
#: ceccomp.adoc:474
#, no-wrap
msgid "emu example"
msgstr "emu 示例"

#. type: Target for macro image
#: ceccomp.adoc:475
#, no-wrap
msgid "emu.png"
msgstr "emu.png"

#. type: Target for macro image
#: ceccomp.adoc:476
#, no-wrap
msgid "emu_quiet.png"
msgstr "emu_quiet.png"

#. type: Title ===
#: ceccomp.adoc:477
#, no-wrap
msgid "trace example"
msgstr "trace 示例"

#. type: Plain text
#: ceccomp.adoc:479
msgid "Running program:"
msgstr "运行程序："

#. type: Target for macro image
#: ceccomp.adoc:480
#, no-wrap
msgid "trace.png"
msgstr "trace.png"

#. type: Plain text
#: ceccomp.adoc:483
msgid "If set `-o FILE`:"
msgstr "如果设置了 `-o FILE` ："

#. type: Target for macro image
#: ceccomp.adoc:484
#, no-wrap
msgid "output_trick.png"
msgstr "output_trick.png"

#. type: Plain text
#: ceccomp.adoc:487
msgid "Pid mode:"
msgstr "PID模式："

#. type: Target for macro image
#: ceccomp.adoc:488
#, no-wrap
msgid "trace_pid.png"
msgstr "trace_pid.png"

#. type: Plain text
#: ceccomp.adoc:491
msgid "Completion for pid mode is available under zsh:"
msgstr "zsh下PID模式可以使用补全："

#. type: Target for macro image
#: ceccomp.adoc:492
#, no-wrap
msgid "trace_completion.png"
msgstr "trace_completion.png"

#. type: Title ===
#: ceccomp.adoc:494
#, no-wrap
msgid "probe example"
msgstr "probe 示例"

#. type: Target for macro image
#: ceccomp.adoc:495
#, no-wrap
msgid "probe.png"
msgstr "probe.png"

#. type: Title ==
#: ceccomp.adoc:498
#, no-wrap
msgid "REPO"
msgstr "仓库"

#. type: Plain text
#: ceccomp.adoc:502
msgid ""
"Visit https://github.com/dbgbgtf1/Ceccomp to find the code.  Pull Requests "
"and Issues are welcome!"
msgstr ""
"在 https://github.com/dbgbgtf1/Ceccomp 可以找到源代码。\n"
"欢迎提交 Pull Requests 和 Issues ！"

#. type: Plain text
#: ceccomp.adoc:503
msgid "Copyright (C) 2025-present, distributed under GPLv3 or later."
msgstr "Copyright (C) 2025-现在，基于 GPLv3 或更新版本分发。"

#~ msgid ""
#~ "A valid _TEXT_ could only contain *statement* like `$A = $arch`, but "
#~ "adding an extra *lineno* may help you much. *lineno* starts from 1, and "
#~ "always bases 10."
#~ msgstr ""
#~ "一个有效的 _TEXT_ 可以只包含 *伪代码* 如 `$A = $arch` ，但是添加一些多余"
#~ "的\n"
#~ "*行号* 可能可以辅助你手写 _TEXT_ 。 *行号* 从1开始，并且永远是十进制的。"

#, no-wrap
#~ msgid "Optional Wrapper"
#~ msgstr "可选的其他字段"

#~ msgid "Only `return ALLOW`, the *statement* is needed."
#~ msgstr "以上例子中，只用 `return ALLOW` 这条 *伪代码* 是需要的。"
