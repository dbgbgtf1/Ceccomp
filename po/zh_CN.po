# localization for ceccomp in Chinese simplified.
# Copyright (C) 2025-present ceccomp contributors
# This file is distributed under the same license as the ceccomp package.
# SPDX-FileCopyrightText: 2025 dbgbgtf 1
#
# SPDX-FileCopyrightText: 2025 RocketDev <ma2014119@outlook.com>
msgid ""
msgstr ""
"Project-Id-Version: ceccomp 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-05 12:21+0800\n"
"PO-Revision-Date: 2025-09-25 20:01+0800\n"
"Last-Translator: RocketDev <ma2014119@outlook.com>\n"
"Language-Team: Chinese <kde-i18n-doc@kde.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Lokalize 25.08.1\n"

#: ../include/config.h:8
#, c-format
msgid ""
"ceccomp %s\n"
"Tag at %s\n"
"Build by %s\n"
msgstr ""
"ceccomp %s\n"
"在 %s 发布\n"
"由 %s 构建\n"

#: ../include/log/error.h:6
msgid "Unable to open file"
msgstr "无法打开文件"

#: ../include/log/error.h:7
msgid "Invalid arch"
msgstr "无效的架构"

#: ../include/log/error.h:8
msgid "Invalid print mode"
msgstr "无效的打印模式"

#: ../include/log/error.h:9
msgid "Invalid color mode"
msgstr "无效的颜色模式"

#: ../include/log/error.h:19
msgid "Invalid syscall_nr"
msgstr "无效的系统调用号"

#: ../include/log/error.h:20
msgid "Invalid syscall args"
msgstr "无效的系统调用参数"

#: ../include/log/error.h:21
msgid "Invalid instruction pointer"
msgstr "无效的 instruction pointer"

#: ../include/log/error.h:22
msgid "Invalid pid"
msgstr "无效的 pid"

#: ../include/log/error.h:23
msgid "Please input syscall_nr to emu"
msgstr "请输入 syscall_nr 来模拟"

#: ../include/log/error.h:26
msgid "Invalid operator"
msgstr "无效的运算符"

#: ../include/log/error.h:27
msgid "Impossible cmp sym enum"
msgstr "不可能的 cmp enum"

#: ../include/log/error.h:28
msgid "Impossible alu sym enum"
msgstr "不可能的 alu enum"

#: ../include/log/error.h:30
msgid "Invalid right value"
msgstr "无效的右值"

#: ../include/log/error.h:31
msgid "Invalid left valiable"
msgstr "无效的左变量"

#: ../include/log/error.h:33
msgid "Invalid idx of $mem"
msgstr "无效的 mem 索引"

#: ../include/log/error.h:34
msgid "Invalid mem statement"
msgstr "无效的 mem 表达式"

#: ../include/log/error.h:36
msgid "Invalid if line"
msgstr "无效的 if 语句"

#: ../include/log/error.h:37
msgid "Invalid return line"
msgstr "无效的 return 语句"

#: ../include/log/error.h:39
msgid "Missing parentheses in return data, example: ERRNO(2)"
msgstr "return 数值缺少括号，示例： ERRNO(2)"

#: ../include/log/error.h:40
msgid "Invalid return data"
msgstr "无效的 return 数值"

#: ../include/log/error.h:43
msgid "Use parentheses to wrap condition, example: (condition)"
msgstr "使用括号来包括条件判断，示例： (条件判断)"

#: ../include/log/error.h:44
msgid "Use 'goto' after (condition)"
msgstr "在 (条件判断) 后使用 'goto'"

#: ../include/log/error.h:46
msgid "Line number to go after 'goto'"
msgstr "在 'goto' 后缺少行号"

#: ../include/log/error.h:47
msgid "Line number to go after ',else goto'"
msgstr "在 ',else goto' 后缺少行号"

#: ../include/log/error.h:48
msgid "Invalid line number after goto"
msgstr "在 'goto' 后的行号无效"

#: ../include/log/error.h:49
msgid "Invalid jmp line number"
msgstr "jmp 的行号无效"

#: ../include/log/error.h:50
msgid "Jmp line number less than pc"
msgstr "jmp 的行号小于 PC"

#: ../include/log/error.h:51
msgid "Invalid asm code"
msgstr "无效的 asm code"

#: ../include/log/error.h:52
msgid "Invalid return value"
msgstr "无效的 return 值"

#: ../include/log/error.h:54
msgid "Line length exceeds 0x400, which shouldn't happen"
msgstr "行长度超过0x400，这不应该发生"

#: ../include/log/error.h:57
msgid "Invalid offset of seccomp_data"
msgstr "seccomp data 的偏移无效"

#: ../include/log/error.h:58
msgid "Store mem before ld or ldx"
msgstr "在 ld 或 ldx 之前先 store mem"

#: ../include/log/error.h:59
msgid "Jt and jf both 0"
msgstr "jt 和 jf 都是 0"

#: ../include/log/error.h:62
msgid "Alu div by zero"
msgstr "ALU 除以零"

#: ../include/log/error.h:63
msgid "Alu lsh or rsh out of range"
msgstr "ALU 左移或右移超出范围"

#: ../include/log/error.h:64
msgid "Jmp out of bpf len"
msgstr "jmp 超出 BPF 长度"

#: ../include/log/error.h:65
msgid "Bpf filter must end with return"
msgstr "BPF 过滤器必须以 return 结尾"

#: ../include/log/error.h:66
msgid "Invalid opertion"
msgstr "无效的操作"

#: ../include/log/error.h:69
msgid ""
"The above code has errors, please check the warnings for specific details"
msgstr "如上的代码出现错误，请从警告获取更多细节"

#: ../include/log/error.h:74
msgid "execv failed executing"
msgstr "无法执行 execv"

#: ../include/log/error.h:75
msgid "tracee syscall should be exiting here"
msgstr "tracee 系统调用在此处应该退出"

#: ../include/log/error.h:76
#, c-format
msgid "Process %d spawned a new pid %d"
msgstr "进程 %d 派生了新进程 %d"

#: ../include/log/error.h:77
#, c-format
msgid "Process %d exited"
msgstr "进程 %d 退出"

#: ../include/log/error.h:78
#, c-format
msgid "Parsing %d process seccomp filter"
msgstr "正在解析 %d 进程的 seccomp 过滤器"

#: ../include/log/error.h:79
#, fuzzy, c-format
#| msgid "Peekdata failed in address: 0x%lx"
msgid "Peekdata failed in address: 0x%p"
msgstr "Peekdata 在 0x%lx 处失败"

#: ../include/log/error.h:81
msgid "Ptrace from 32-bit tracer to 64-bit tracee is limited"
msgstr "从 32位tracer 到 64位tracee 的 Ptrace 受到限制"

#: ../include/log/error.h:84
msgid "Procfs not accessible, unable to perform"
msgstr "Procfs 无法访问，无法执行"

#: ../include/log/error.h:85
#, c-format
msgid "Target process is being traced by %d pid process"
msgstr "目标进程正在被 %d 进程所追踪"

#: ../include/log/error.h:89
msgid "Run with CAP_SYS_PTRACE capability to seize a foreign process"
msgstr "以 CAP_SYS_PTRACE 权能运行来附加到一个外部进程"

#: ../include/log/error.h:90
msgid "Kernel thread can not be seized"
msgstr "内核线程不能被附加"

#: ../include/log/error.h:92
msgid "perhaps seizing kthread or lacking CAP_SYS_PTRACE"
msgstr "可能正在附加到内核线程或缺少 CAP_SYS_PTRACE 权能"

#: ../include/log/error.h:93
#, c-format
msgid "No such process with pid %d in the system"
msgstr "不存在 pid 为 %d 的进程"

#: ../include/log/error.h:94
msgid "Non-cbpf found, can't resolve, but continue"
msgstr "发现了无法解析的 non-cbpf，继续"

#: ../include/log/error.h:99
msgid ""
"perhaps PTRACE_GET_SECCOMP_FILTER is not supported or no seccomp filter in "
"target process"
msgstr ""
"可能 PTRACE_SECCOMP_GET_FILTER 在您的系统上不支持或目标进程没有 seccomp 过滤"
"器"

#: ../include/log/error.h:103
msgid "PTRACE_GET_SECCOMP_FILTER is not supported on your system"
msgstr "PTRACE_SECCOMP_GET_FILTER 在您的系统上不支持"

#: ../include/log/error.h:104
msgid "Error cause unknown, due to the followings"
msgstr "发生未知的错误，由于如下的原因"

#: ../include/log/error.h:106
msgid ""
"Ceccomp is in seccomp mode, fetch seccomp filters of other process is not "
"permitted"
msgstr "Ceccomp 处在 seccomp 模式，不允许获取其他进程的 seccomp 过滤器"

#: ../include/log/error.h:110
msgid "Run with CAP_SYS_ADMIN capability to fetch seccomp filters"
msgstr "以 CAP_SYS_ADMIN 权能运行来获取 seccomp 过滤器"

#: ../include/log/error.h:112
msgid "perhaps lacking CAP_SYS_ADMIN or ceccomp is in seccomp mode"
msgstr "可能缺少 CAP_SYS_ADMIN 权能或 ceccomp 处于 seccomp 模式"

#: ../include/log/error.h:114
#, c-format
msgid "No seccomp filters found in pid %d\n"
msgstr "在 pid %d 中没有找到 seccomp 过滤器\n"

#: ../include/help.h:2
msgid "Usage: ceccomp <subcommand> <args> <options>\n"
msgstr "用法： ceccomp <子命令> <参数> <选项>\n"

#: ../include/help.h:23
msgid ""
"asm      -- Assemble bpf text to raw bytes\n"
"disasm   -- Disassemble raw bytes to bpf text\n"
"emu      -- Emulate bpf program with given syscall and bpf text\n"
"help     -- Display ceccomp help information\n"
"probe    -- Trace the program for the first filter and emulate common "
"syscalls\n"
"trace    -- Run program or trace pid, extract bpf filter and then print to "
"text\n"
"version  -- Display ceccomp version\n"
msgstr ""
"asm      -- 把 bpf text 编译为 raw bytes\n"
"disasm   -- 把 raw bytes 编译为 bpf text\n"
"emu      -- 在给定的 syscall 和 bpf text 下模拟 bpf 程序的结果\n"
"help     -- 显示帮助信息\n"
"probe    -- trace 程序，对程序中出现的第一个 filter 模拟常见的 syscall\n"
"trace    -- 运行程序或追踪指定 pid，提取 bpf 过滤器，并打印 text 结果\n"
"version  -- 显示 ceccomp 版本\n"

#: ../include/help.h:35
msgid ""
"Options:\n"
"-a, --arch (x86_64|aarch64|...)  Which architecture to resolve syscall_nr, "
"default as your arch\n"
"-f, --fmt (hexline|hexfmt|raw)   Output format, default as hexline\n"
"-p, --pid system_process_id      Extract bpf filters from process and print "
"with bpf text form; CAP_SYS_ADMIN is needed to work\n"
"-o, --output file                Print to file to avoid mixing ceccomp "
"output and tracee program output, default as stderr\n"
"-q, --quiet                      Print emulate result only\n"
"-c, --color                      When to print in color, default as auto\n"
"syscall_nr                       System call number or name (e.g. 0|read)\n"
"args[0-5], ip                    args and ip (instruction pointer) used for "
"emulation, default as 0\n"
"raw, text                        File with BPF RAW or BPF TEXT, see docs for "
"detail, default as stdin\n"
msgstr ""
"选项:\n"
"-a, --arch (x86_64|aarch64|...)  选择哪一个架构来解析 syscall_nr，默认为你的"
"架构\n"
"-f, --fmt (hexline|hexfmt|raw)   输出格式, 默认为 hexline\n"
"-p, --pid system_process_id      从进程中提取 bpf 过滤器，并打印为 text 格"
"式; 需要 CAP_SYS_ADMIN 来运作\n"
"-o, --output file                将结果打印到文件来避免混淆 ceccomp 输出和 "
"tracee 程序输出，默认打印至 stderr\n"
"-q, --quiet                      只打印 emulate 结果\n"
"-c, --color                      指定何时使用彩色输出, 默认为 auto\n"
"syscall_nr                       系统调用号或系统调用名 (示例 0|read)\n"
"args[0-5], ip                    用来模拟的系统调用的参数和 ip (instruction "
"pointer)，默认为 0\n"
"raw, text                        raw 或 text 文件，默认为 stdin。更多细节请查"
"阅文档\n"

#: ../src/trace.c:40
msgid "STRICT MODE DETECTED!"
msgstr "检测到 严格模式 ！"

#: ../src/trace.c:41
msgid "Only read, write, _exit, sigreturn available!"
msgstr "只能使用 read, write, _exit, sigreturn 系统调用！"
