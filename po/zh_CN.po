# localization for ceccomp in Chinese simplified.
# Copyright (C) 2025-present ceccomp contributors
# This file is distributed under the same license as the ceccomp package.
# SPDX-FileCopyrightText: 2025 dbgbgtf 1
#
# SPDX-FileCopyrightText: 2025 RocketDev <ma2014119@outlook.com>
msgid ""
msgstr ""
"Project-Id-Version: ceccomp 4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-05 01:22+0800\n"
"PO-Revision-Date: 2026-02-05 01:22+0800\n"
"Last-Translator: RocketDev <ma2014119@outlook.com>\n"
"Language-Team: Chinese <ma2014119@outlook.com>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.8\n"

#: ../include/config.h:11
#, c-format
msgid ""
"ceccomp %s\n"
"Tag at %s\n"
"Build by %s\n"
msgstr ""
"ceccomp %s\n"
"在 %s 发布\n"
"由 %s 构建\n"

#: ../include/help.h:5
msgid "Usage: ceccomp <subcommand> <args> <options>\n"
msgstr "用法： ceccomp <子命令> <参数> <选项>\n"

#: ../include/help.h:25
msgid ""
"asm      -- Assemble bpf text to raw bytes\n"
"disasm   -- Disassemble raw bytes to bpf text\n"
"emu      -- Emulate bpf program with given syscall and bpf text\n"
"help     -- Display ceccomp help information\n"
"probe    -- Trace the program for the first filter and emulate common "
"syscalls\n"
"trace    -- Run program or trace pid, extract bpf filter and then print to "
"text\n"
"version  -- Display ceccomp version\n"
msgstr ""
"asm      -- 把 bpf text 编译为 raw bytes\n"
"disasm   -- 把 raw bytes 编译为 bpf text\n"
"emu      -- 在给定的 syscall 和 bpf text 下模拟 bpf 程序的结果\n"
"help     -- 显示帮助信息\n"
"probe    -- trace 程序，对程序中出现的第一个 filter 模拟常见的 syscall\n"
"trace    -- 运行程序或追踪指定 pid，提取 bpf 过滤器，并打印 text 结果\n"
"version  -- 显示 ceccomp 版本\n"

#: ../include/help.h:36
msgid ""
"Options:\n"
"-a, --arch (x86_64|aarch64|...)  Which architecture to resolve syscall_nr, "
"read or write bytestream by the byteorder of arch, default as your arch\n"
"-f, --fmt (hexline|hexfmt|raw)   Output format, default as hexline\n"
"-p, --pid system_process_id      Extract bpf filters from process and print "
"with bpf text form; CAP_SYS_ADMIN is needed to work\n"
"-o, --output file                Print to file to avoid mixing ceccomp "
"output and tracee program output, default as stderr\n"
"-q, --quiet                      Print emulate result only or suppress the "
"process info message in trace and probe\n"
"-s, --seize                      Follow process to trace load-filter "
"operation\n"
"-c, --color (auto|always|never)  When to print in color, default as auto\n"
"syscall_nr                       System call number or name (e.g. 0|read)\n"
"args[0-5], ip                    args and ip (instruction pointer) used for "
"emulation, default as 0\n"
"raw, text                        File with BPF RAW or BPF TEXT, see docs for "
"detail, default as stdin\n"
msgstr ""
"选项:\n"
"-a, --arch (x86_64|aarch64|...)  选择哪一个架构来解析 syscall_nr，默认为你的"
"架构\n"
"-f, --fmt (hexline|hexfmt|raw)   输出格式, 默认为 hexline\n"
"-p, --pid system_process_id      从进程中提取 bpf 过滤器，并打印为 text 格"
"式; 需要 CAP_SYS_ADMIN 来运作\n"
"-o, --output file                将结果打印到文件来避免混淆 ceccomp 输出和 "
"tracee 程序输出，默认打印至 stderr\n"
"-q, --quiet                      只打印 emulate 结果或在 trace 和 probe 时抑"
"制进程的 INFO 消息\n"
"-s, --seize                      追踪进程以分析加载过滤器的操作\n"
"-c, --color (auto|always|never)  指定何时使用彩色输出, 默认为 auto\n"
"syscall_nr                       系统调用号或系统调用名 (示例 0|read)\n"
"args[0-5], ip                    用来模拟的系统调用的参数和 ip (instruction "
"pointer)，默认为 0\n"
"raw, text                        raw 或 text 文件，默认为 stdin。更多细节请查"
"阅文档\n"

#: ../include/utils/error.h:7
msgid "Found errors when assembling BPF from trace"
msgstr "当汇编从 trace 取得的 BPF 时发现错误"

#: ../include/utils/error.h:8
#, c-format
msgid "Failed to request a temporary file: %s"
msgstr "无法申请临时文件：%s"

#: ../include/utils/error.h:12
msgid "Found errors when assembling text before emulating"
msgstr "在模拟前汇编 text 时发现错误"

#: ../include/utils/error.h:13
msgid "Please input syscall_nr (syscall name or number)"
msgstr "请输入 syscall_nr（syscall 名字或数字）"

#: ../include/utils/error.h:14
msgid "Invalid syscall_nr"
msgstr "无效的系统调用号"

#: ../include/utils/error.h:17
msgid "Found errors when assembling"
msgstr "汇编时发现错误"

#: ../include/utils/error.h:20
msgid "Found fatal errors when disassembling"
msgstr "反汇编时发现致命错误"

#: ../include/utils/error.h:21
msgid "The input is empty"
msgstr "输入为空"

#: ../include/utils/error.h:23
msgid "The input is larger than 1024 filters! Perhaps inputting a wrong file?"
msgstr "输入大小超过了 1024 个过滤器的大小！可能输入了错误的文件？"

#: ../include/utils/error.h:26
#, c-format
msgid "%d byte(s) at the end of input could not fit into a filter"
msgstr "输入末尾的 %d 个字节无法放入一个过滤器中"

#: ../include/utils/error.h:29
#, c-format
msgid "Attaching to process %d"
msgstr "正在附加到进程 %d"

#: ../include/utils/error.h:30
#, c-format
msgid "Peekdata failed at %p"
msgstr "无法在 %p peekdata"

#: ../include/utils/error.h:31
msgid "Failed to execute new program"
msgstr "无法执行新程序"

#: ../include/utils/error.h:32
#, c-format
msgid "Process %d spawned a new pid %d"
msgstr "进程 %d 派生了新进程 %d"

#: ../include/utils/error.h:33
#, c-format
msgid "Process %d exited"
msgstr "进程 %d 退出"

#: ../include/utils/error.h:34
#, c-format
msgid "Parsing seccomp filter loaded in process %d"
msgstr "正在解析进程 %d 加载的 seccomp 过滤器"

#: ../include/utils/error.h:35
#, c-format
msgid "Process %d failed to load seccomp filter"
msgstr "进程 %d 加载 seccomp 过滤器失败"

#: ../include/utils/error.h:36
msgid "Procfs not accessible, unable to perform"
msgstr "Procfs 无法访问，无法执行"

#: ../include/utils/error.h:37
msgid "Found unresolvable non-classic BPF, skipping"
msgstr "发现无法解析的非经典 BPF，跳过"

#: ../include/utils/error.h:38
msgid "Kernel thread can not be seized"
msgstr "内核线程不能被附加"

#: ../include/utils/error.h:39
#, c-format
msgid "No seccomp filters found in process %d"
msgstr "在进程 %d 中没有找到 seccomp 过滤器"

#: ../include/utils/error.h:41
#, c-format
msgid "Target process is already being traced by process %d"
msgstr "目标进程已经被进程 %d 追踪"

#: ../include/utils/error.h:43
#, c-format
msgid ""
"Process %d loaded strict seccomp mode, which only allows read, write, "
"exit_group and sigreturn!"
msgstr ""
"进程 %d 加载了严格 seccomp 模式，只有 read, write, exit_group 和 sigreturn 被"
"允许！"

#: ../include/utils/error.h:45
#, c-format
msgid "Unknown error when get filter: %s"
msgstr "在 get filter 时发生未知错误：%s"

#: ../include/utils/error.h:46
#, c-format
msgid "Unknown error when seizing process: %s"
msgstr "在附加到进程时发生未知错误：%s"

#: ../include/utils/error.h:47
msgid "The process to seize does not exist"
msgstr "要附加的进程不存在"

#: ../include/utils/error.h:53
msgid "perhaps seizing kthread or lacking CAP_SYS_PTRACE"
msgstr "可能正在附加到内核线程或缺少 CAP_SYS_PTRACE 权能"

#: ../include/utils/error.h:55
msgid "Run with CAP_SYS_ADMIN capability to fetch seccomp filters"
msgstr "以 CAP_SYS_ADMIN 权能运行来获取 seccomp 过滤器"

#: ../include/utils/error.h:57
msgid "Run with CAP_SYS_PTRACE capability to seize a foreign process"
msgstr "以 CAP_SYS_PTRACE 权能运行来附加到一个外部进程"

#: ../include/utils/error.h:59
msgid "32-bit tracer can not ptrace 64-bit tracee"
msgstr "32 位 tracer 无法 ptrace 64 位 tracee"

#: ../include/utils/error.h:61
#, c-format
msgid "libseccomp does not support the tracee's arch (%#x)"
msgstr "libseccomp 不支持 tracee 的架构 (%#x)"

#: ../include/utils/error.h:63
msgid "perhaps lacking CAP_SYS_ADMIN or ceccomp is in seccomp mode"
msgstr "可能缺少 CAP_SYS_ADMIN 权能或 ceccomp 处于 seccomp 模式"

#: ../include/utils/error.h:65
msgid "PTRACE_GET_SECCOMP_FILTER is not supported on your system"
msgstr "PTRACE_SECCOMP_GET_FILTER 在您的系统上不支持"

#: ../include/utils/error.h:67
msgid ""
"Ceccomp is in seccomp mode, fetching seccomp filters of other process is not "
"permitted"
msgstr "Ceccomp 处在 seccomp 模式，不允许获取其他进程的 seccomp 过滤器"

#: ../include/utils/error.h:70
msgid ""
"perhaps PTRACE_GET_SECCOMP_FILTER is not supported or no seccomp filter in "
"target process"
msgstr ""
"可能 PTRACE_SECCOMP_GET_FILTER 在您的系统上不支持或目标进程没有 seccomp 过滤"
"器"

#: ../include/utils/error.h:74
msgid "Invalid color mode"
msgstr "无效的颜色模式"

#: ../include/utils/error.h:75
msgid "Invalid format mode"
msgstr "无效的 asm 格式参数"

#: ../include/utils/error.h:76
msgid "Invalid number"
msgstr "无效的数字"

#: ../include/utils/error.h:77
#, c-format
msgid "Unable to open file %s: %s"
msgstr "无法打开文件 %s: %s"

#: ../include/utils/error.h:80
#, c-format
msgid "Reading input failed: %s"
msgstr "读取输入失败：%s"

#: ../include/utils/error.h:82
#, c-format
msgid "Found '\\0' at file offset %lu, perhaps it's not a text file?"
msgstr "在文件偏移 %lu 处发现 '\\0'，可能不是一个文本文件？"

#: ../include/utils/error.h:84
msgid "No line break in source file, perhaps it's not a text file?"
msgstr "没有在源文件中找到换行符，可能不是一个文本文件？"

#: ../include/utils/error.h:86
#, c-format
msgid "Line %u has more than %u bytes, perhaps the input is not a text file?"
msgstr "第 %u 行上有超过 %u 个字节，可能输入不是一个文本文件？"

#: ../include/utils/error.h:87
msgid "The input file is greater than 1 MiB!"
msgstr "输入的文件超过了 1 MiB！"

#: ../include/utils/error.h:89
msgid "Found more than 4096 lines of text, perhaps it's not for ceccomp?"
msgstr "文件中包含超过 4096 行，可能它不是给 ceccomp 用的？"

#: ../include/utils/error.h:92
msgid "Can not find label declaration"
msgstr "无法找到标签声明"

#: ../include/utils/error.h:95
msgid "Unexpected token"
msgstr "意料之外的 token"

#: ../include/utils/error.h:96
msgid "Found duplicated label declaration"
msgstr "发现重复的标签声明"

#: ../include/utils/error.h:97
msgid "Input number exceeds 32-bit range"
msgstr "输入的数字超过了 32 位的范围"

#: ../include/utils/error.h:99
msgid "Expect operator"
msgstr "期待一个操作符"

#: ../include/utils/error.h:100
msgid "Expect rvalue"
msgstr "期待一个右值"

#: ../include/utils/error.h:101
msgid "Expect return value"
msgstr "期待一个 return 值"

#: ../include/utils/error.h:103
msgid "Expect number"
msgstr "期待一个数字"

#: ../include/utils/error.h:104
msgid "Expect parenthesis"
msgstr "期待一个小括号"

#: ../include/utils/error.h:105
msgid "Expect bracket"
msgstr "期待一个中括号"

#: ../include/utils/error.h:106
msgid "Expect comparator"
msgstr "期待一个比较符"

#: ../include/utils/error.h:107
msgid "Expect label"
msgstr "期待一个标签"

#: ../include/utils/error.h:108
msgid "Expect syscall"
msgstr "期待一个系统调用"

#: ../include/utils/error.h:109
msgid "Expect architecture"
msgstr "期待一个架构"

#: ../include/utils/error.h:112
msgid "Expect 'goto'"
msgstr "期待一个 'goto'"

#: ../include/utils/error.h:113
msgid "Expect '$A'"
msgstr "期待一个 '$A'"

#: ../include/utils/error.h:114
msgid "Expect 'else'"
msgstr "期待一个 'else'"

#: ../include/utils/error.h:117
msgid "Rvalue should be '$A'"
msgstr "右值应该为 '$A'"

#: ../include/utils/error.h:118
msgid "Rvalue can not be '$A'"
msgstr "右值不能为 '$A'"

#: ../include/utils/error.h:119
msgid "Rvalue can not be '$X'"
msgstr "右值不能为 '$X'"

#: ../include/utils/error.h:121
msgid "Rvalue should be '$A' or '$X'"
msgstr "右值应该为 '$A' 或 '$X'"

#: ../include/utils/error.h:122
msgid "Rvalue should be '$X' or number"
msgstr "右值应该为 '$X' 或数字"

#: ../include/utils/error.h:123
msgid "Operator should be '='"
msgstr "操作符应该为 '='"

#: ../include/utils/error.h:124
msgid "Lvalue should be '$A'"
msgstr "左值应该为 '$A'"

#: ../include/utils/error.h:125
msgid "seccomp_data load offset must be 4-byte aligned"
msgstr "seccomp_data 加载偏移必须对齐到 4 字节"

#: ../include/utils/error.h:127
msgid "Args index out of range (0-5)"
msgstr "访问 args 索引超出范围 (0-5)"

#: ../include/utils/error.h:128
msgid "Mem index out of range (0-15)"
msgstr "访问 mem 索引超出范围 (0-5)"

#: ../include/utils/error.h:129
msgid "Accessing uninitialized mem"
msgstr "尝试访问未初始化的 mem"

#: ../include/utils/error.h:130
msgid "Dividing by zero"
msgstr "除以零"

#: ../include/utils/error.h:131
msgid "Left or right shifting more than 32 bits"
msgstr "左移或右移超过 32 位"

#: ../include/utils/error.h:133
msgid "Data carried by return motion exceeds 0xffff"
msgstr "return 动作携带的 data 超过了 0xffff"

#: ../include/utils/error.h:134
msgid "JT is larger than 0xff"
msgstr "JT 大于了 0xff"

#: ../include/utils/error.h:135
msgid "JT must be positive"
msgstr "JT 必须是正数"

#: ../include/utils/error.h:136
msgid "JF is larger than 0xff"
msgstr "JF 大于了 0xff"

#: ../include/utils/error.h:137
msgid "JF must be positive"
msgstr "JF 必须是正数"

#: ../include/utils/error.h:138
msgid "JT out of filters"
msgstr "JT 超出 BPF 长度"

#: ../include/utils/error.h:139
msgid "JF out of filters"
msgstr "JF 超出 BPF 长度"

#: ../include/utils/error.h:140
msgid "JA out of filters"
msgstr "跳转结果超出 BPF 长度"

#: ../include/utils/error.h:142
msgid "BPF filters must end with return"
msgstr "BPF 过滤器必须以 return 结尾"

#: ../include/utils/error.h:143
msgid "The input does not contain any valid statement"
msgstr "输入不包含任何有效的伪代码"

#: ../include/utils/error.h:145
msgid "Invalid or unknown operation"
msgstr "无效或未知的操作符"

#~ msgid "Invalid attribute loading"
#~ msgstr "无效的属性加载"

#~ msgid "JT to a invalid tag out of filters"
#~ msgstr "JT 到了一个超出过滤器的标签"

#~ msgid "JF to a invalid tag out of filters"
#~ msgstr "JF 到了一个超出过滤器的标签"

#~ msgid "Jf to a invalid tag out of filters"
#~ msgstr "JF 到了一个超出过滤器的标签"

#~ msgid "Lvalue should be A"
#~ msgstr "左值应该为 "

#~ msgid "execv failed executing"
#~ msgstr "无法执行 execv"

#~ msgid "Non-cbpf found, can't resolve, but continue"
#~ msgstr "发现了无法解析的 non-cbpf，继续"

#~ msgid "Alu lsh or rsh out of range"
#~ msgstr "ALU 左移或右移超出范围"

#~ msgid "STRICT MODE DETECTED!"
#~ msgstr "检测到 严格模式 ！"

#~ msgid "Only read, write, _exit, sigreturn available!"
#~ msgstr "只能使用 read, write, _exit, sigreturn 系统调用！"

#~ msgid "Invalid arch"
#~ msgstr "无效的架构"

#~ msgid "Invalid syscall args"
#~ msgstr "无效的系统调用参数"

#~ msgid "Invalid instruction pointer"
#~ msgstr "无效的 instruction pointer"

#~ msgid "Invalid pid"
#~ msgstr "无效的 pid"

#, c-format
#~ msgid ""
#~ "Your system arch (%s) does not match any arch supported by libseccomp, "
#~ "please set an arch by -a manually"
#~ msgstr ""
#~ "您的系统架构 (%s) 没有匹配到任何受 libseccomp 支持的架构。请使用 -a 手动设"
#~ "置架构"

#~ msgid "Invalid operator"
#~ msgstr "无效的运算符"

#~ msgid "Impossible cmp sym enum"
#~ msgstr "不可能的 cmp enum"

#~ msgid "Impossible alu sym enum"
#~ msgstr "不可能的 alu enum"

#~ msgid "Invalid right value"
#~ msgstr "无效的右值"

#~ msgid "Invalid left valiable"
#~ msgstr "无效的左变量"

#~ msgid "Invalid idx of $mem"
#~ msgstr "无效的 mem 索引"

#~ msgid "Invalid mem statement"
#~ msgstr "无效的 mem 表达式"

#~ msgid "Invalid if line"
#~ msgstr "无效的 if 语句"

#~ msgid "Invalid return line"
#~ msgstr "无效的 return 语句"

#~ msgid "Missing parentheses in return data, example: ERRNO(2)"
#~ msgstr "return 数值缺少括号，示例： ERRNO(2)"

#~ msgid "Invalid return data"
#~ msgstr "无效的 return 数值"

#~ msgid "Use parentheses to wrap condition, example: (condition)"
#~ msgstr "使用括号来包括条件判断，示例： (条件判断)"

#~ msgid "Use 'goto' after (condition)"
#~ msgstr "在 (条件判断) 后使用 'goto'"

#~ msgid "Line number to go after 'goto'"
#~ msgstr "在 'goto' 后缺少行号"

#~ msgid "Line number to go after ',else goto'"
#~ msgstr "在 ',else goto' 后缺少行号"

#~ msgid "Invalid line number after goto"
#~ msgstr "在 'goto' 后的行号无效"

#~ msgid "Jmp line number less than pc"
#~ msgstr "jmp 的行号小于 PC"

#~ msgid "Invalid asm code"
#~ msgstr "无效的 asm code"

#~ msgid "Line length shall not exceeds 0x400"
#~ msgstr "一行的长度不应超过 0x400"

#~ msgid "Invalid offset of seccomp_data"
#~ msgstr "seccomp data 的偏移无效"

#~ msgid "Store mem before ld or ldx"
#~ msgstr "在 ld 或 ldx 之前先 store mem"

#~ msgid "Jt and jf both 0"
#~ msgstr "jt 和 jf 都是 0"

#~ msgid ""
#~ "The above code has errors, please check the warnings for specific details"
#~ msgstr "如上的代码出现错误，请从警告获取更多细节"

#~ msgid "tracee syscall should be exiting here"
#~ msgstr "tracee 系统调用在此处应该退出"

#, c-format
#~ msgid "No such process with pid %d in the system"
#~ msgstr "不存在 pid 为 %d 的进程"

#~ msgid "Error cause unknown, due to the followings"
#~ msgstr "发生未知的错误，由于如下的原因"
