# localization for ceccomp in Chinese simplified.
# Copyright (C) 2025-present ceccomp contributors
# This file is distributed under the same license as the ceccomp package.
# dbgbgtf1 <dudududumaxver@outlook.com>
#
msgid ""
msgstr ""
"Project-Id-Version: ceccomp 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-16 10:40+0800\n"
"PO-Revision-Date: 2025-09-16 10:37+0800\n"
"Last-Translator: dbgbgtf1 <dudududumaxver@outlook.com>\n"
"Language-Team: zh_CN <dudududumaxver@outlook.com>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: include/log/error.h:9
msgid "Unable to open file"
msgstr "无法打开文件"

#: include/log/error.h:10
msgid "Invalid arch"
msgstr "无效的架构"

#: include/log/error.h:11
msgid "Invalid print mode"
msgstr "无效的打印模式"

#: include/log/error.h:12
msgid "Invalid color mode"
msgstr "无效的颜色模式"

#: include/log/error.h:22
msgid "Invalid syscall nr"
msgstr "无效的系统调用号"

#: include/log/error.h:23
msgid "Invalid syscall args"
msgstr "无效的系统调用参数"

#: include/log/error.h:24
msgid "Invalid instruction pointer"
msgstr "无效的instruction pointer"

#: include/log/error.h:25
msgid "Invalid pid"
msgstr "无效的pid"

#: include/log/error.h:26
msgid "Please input syscall_nr to emu"
msgstr "请输入syscall_nr来模拟"

#: include/log/error.h:29
msgid "Invalid operator"
msgstr "无效的运算符"

#: include/log/error.h:30
msgid "Inpossible cmp sym enum"
msgstr "不可能的cmp enum"

#: include/log/error.h:31
msgid "Inpossible alu sym enum"
msgstr "不可能的cmp enum"

#: include/log/error.h:33
msgid "Invalid right value"
msgstr "无效的右值"

#: include/log/error.h:34
msgid "Invalid left valiable"
msgstr "无效的左变量"

#: include/log/error.h:36
msgid "Invalid idx of $mem"
msgstr "无效的mem索引"

#: include/log/error.h:37
msgid "Invalid mem statement"
msgstr "无效的mem表达式"

#: include/log/error.h:39
msgid "Invalid if line"
msgstr "无效的if语句"

#: include/log/error.h:40
msgid "Invalid return line"
msgstr "无效的return语句"

#: include/log/error.h:41
msgid "Missing parentheses in return data, example: ERRNO(2)"
msgstr "ret数值缺少括号，示例：ERRNO(2)"

#: include/log/error.h:42
msgid "Invalid return data"
msgstr "无效的return数值"

#: include/log/error.h:44
msgid "Use parentheses to wrap condition, example: (condition)"
msgstr "使用括号来包括条件判断，示例：(条件判断)"

#: include/log/error.h:45
msgid "Use 'goto' after (condition)"
msgstr "在(条件判断)后使用'goto'"

#: include/log/error.h:47
msgid "Line number to go after 'goto'"
msgstr "在'goto'后缺少行号"

#: include/log/error.h:48
msgid "Line number to go after ',else goto'"
msgstr "在',else goto'后缺少行号"

#: include/log/error.h:49
msgid "Invalid line number after goto"
msgstr "在'goto'后的行号无效"

#: include/log/error.h:50
msgid "Invalid jmp line number"
msgstr "jmp的行号无效"

#: include/log/error.h:51
msgid "Invalid asm code"
msgstr "无效的asm code"

#: include/log/error.h:52
msgid "Invalid return value"
msgstr "无效的return值"

#: include/log/error.h:55
msgid "Invalid offset of seccomp_data"
msgstr "seccomp data的偏移无效"

#: include/log/error.h:56
msgid "Store mem before ld or ldx"
msgstr "在ld或ldx之前先store mem"

#: include/log/error.h:57
msgid "Jt and jf both 0"
msgstr "jt和jf都是0"

#: include/log/error.h:60
msgid "Alu div by zero"
msgstr "Alu 除以零"

#: include/log/error.h:61
msgid "Alu lsh or rsh out of range"
msgstr "Alu 左移或右移超出范围"

#: include/log/error.h:62
msgid "Jmp out of bpf len"
msgstr "jmp超出bpf长度"

#: include/log/error.h:63
msgid "Bpf filter must end with return"
msgstr "bpf过滤器必须以return结尾"

#: include/log/error.h:64
msgid "Invalid opertion"
msgstr "无效的操作"

#: include/log/error.h:67
msgid ""
"The above code has errors, please check the warnings for specific details"
msgstr "如上的代码出现错误，请从警告获取更多细节"

#: include/log/error.h:71
msgid ""
"Run with CAP_SYS_ADMIN capability when trace pid\n"
"and kernel pid can't be trace"
msgstr ""
"trace pid时需要CAP_SYS_ADMIN\n"
"另外内核进程无法被trace"

#: include/log/error.h:73
#, c-format
msgid "No such process with pid %d in the system"
msgstr "不存在pid为%d的进程"

#: include/log/error.h:74
msgid "Non-cbpf found, can't resolve, but continue"
msgstr "发现了无法解析的Non-cbpf，继续"

#: include/log/error.h:75
msgid "execv failed executing"
msgstr "无法执行execv"

#: include/log/error.h:76
msgid "tracee syscall should be exiting here"
msgstr "tracee系统调用在此处应该退出"

#: include/log/error.h:78
msgid "PTRACE_SECCOMP_GET_FILTER is not supported on your system"
msgstr "PTRACE_SECCOMP_GET_FILTER在您的系统上不支持"

#: include/log/error.h:79
msgid "Error cause unknown, due to the followings"
msgstr "发生未知的错误，由于如下的原因"

#: include/log/error.h:80
msgid "tracee in strict mode"
msgstr "tracee处在strict mode"

#: include/log/error.h:82
msgid ""
"Ceccomp is in seccomp, kernel forbid tracer in seccomp to get tracee filter"
msgstr "Ceccomp处在沙箱中，内核不允许沙箱中的tracer获取tracee的bpf过滤器"

#: include/help.h:21
msgid ""
"asm      -- Assemble bpf text to raw bytes\n"
"disasm   -- Disassemble raw bytes to bpf text\n"
"emu      -- Emulate bpf program with given syscall and bpf text\n"
"help     -- Display ceccomp help information\n"
"probe    -- Trace the program for the first filter and emulate common "
"syscalls\n"
"trace    -- Run program or trace pid, extract bpf filter and then print to "
"text\n"
"version  -- Display ceccomp version\n"
msgstr ""
"asm      -- 把bpf text编译为raw bytes\n"
"disasm   -- 把raw bytes编译为bpf text\n"
"emu      -- 在给定的syscall和bpf text下模拟bpf程序的结果\n"
"help     -- 显示帮助信息\n"
"probe    -- trace程序，对程序中出现的第一个filter模拟常见的syscall\n"
"trace    -- 运行程序或追踪指定pid，提取bpf过滤器，并打印text结果\n"
"version  -- 显示ceccomp版本\n"

#: include/help.h:33
msgid ""
"Options:\n"
"-a, --arch (x86_64|aarch64|...)  Which architecture to resolve syscall_nr, "
"default as your arch\n"
"-f, --fmt (hexline|hexfmt|raw)   Output format, default as hexline\n"
"-p, --pid system_process_id      Extract bpf filters from process and print "
"with bpf text form; CAP_SYS_ADMIN is needed to work\n"
"-o, --output file                Print to file to avoid mixing ceccomp "
"output and tracee program output, default as stderr\n"
"-q, --quiet                      Print emulate result only\n"
"-c, --color                      When to print in color, default as auto\n"
"syscall_nr                       System call number or name (e.g. 0|read)\n"
"args[0-5], ip                    args and ip (instruction pointer) used for "
"emulation, default as 0\n"
"raw, text                        File with BPF RAW or BPF TEXT, see docs for "
"detail, default as stdin\n"
msgstr ""
"Options:\n"
"-a, --arch (x86_64|aarch64|...)  选择哪一个架构来解析syscall_nr, 默认为你的架"
"构\n"
"-f, --fmt (hexline|hexfmt|raw)   输出格式, 默认为hexline\n"
"-p, --pid system_process_id      从进程中提取bpf过滤器，并打印为text格式; 需"
"要CAP_SYS_ADMIN来运作\n"
"-o, --output file                将结果打印到文件来避免混淆ceccomp输出和"
"tracee程序输出，默认打印至stderr\n"
"-q, --quiet                      只打印emulate结果\n"
"-c, --color                      指定何时使用彩色输出, 默认为auto\n"
"syscall_nr                       系统调用号或系统调用名 (示例 0|read)\n"
"args[0-5], ip                    用来模拟的系统调用的参数和ip(instruction "
"pointer)，默认为0\n"
"raw, text                        raw或text文件，默认为stdin。更多细节请查阅文"
"档\n"
